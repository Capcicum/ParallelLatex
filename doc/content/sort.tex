The ability to sort an array is important in programming, in both a serial and parallel context. Sorting is to arrange elements of a set in a specific way, e.g. numerical or lexicographical sorting. This section will only focus on examples and sorting of numerical minimum to maximum sorting. A definition of numerical minimum to maximum sort is seen in \cref{def:al_sort}.   

\begin{definition}
	\label{def:al_sort}
	\textit{The sort operation takes an unordered set of n elements}
	\begin{center}
		$[a_0,a_1,...,a_{n-1}],$
	\end{center}
	\textit{and returns the permutation}
	\begin{center}
		$sgn([a_0,a_1,...,a_{n-1}])$
	\end{center}
\end{definition}
\begin{example}
	With the input array
	\begin{center}
		$[3,6,9,1,2,6,2,3],$
	\end{center}
	the return of the sort is
	\begin{center}
		$[1,2,2,3,3,6,6,9].$
	\end{center}
\end{example}

There are many different implementations and strategies for sorting, both serial and parallel. Many factors a present when choosing a sorting algorithm for an application. For the serial implementations examples of sorting algorithm is Quicksort, Merge sort, Heapsort and Bubble sort. Sorting algorithms complexity is often described using time complexity, as the work and step comlexity for serial algorithms are equal. The time complexity can be divided into 3 categories namely worst, average and best. these categories are used as sorting algorithm, may complete in different times, determined by the order of the input element e.g. they are already ordered. The complexities for different serial algorithms are seen in \cref{tab:serial_sort} \cite{wiki:sort}. 

\begin{table}[ht]
	\centering
	\caption{Serial sorting algorithms best, average and worst complexity}
	\label{tab:serial_sort}
	\begin{tabular}{|c|c|c|c|}
		\hline
		Name           & Best       & Average   & Worst     \\ \hline
		Bubble sort    & $n$        & $n^2$     & $n^2$     \\ \hline
		Merge sort     & $n~log~n$  & $n~log~n$ & $n~log~n$ \\ \hline
		Quicksort      & $n~log~n$  & $n~log~n$ & $n^2$     \\ \hline
		Heapsort       & $n~log~n$  & $n~log~n$ & $n~log~n$ \\ \hline
		Insertion sort & $n$        & $n^2$     & $n^2$     \\ \hline
		Selection sort & $n^2$      & $n^2$     & $n^2$     \\ \hline
	\end{tabular}
\end{table}


As seen the work and step complexity of the serial sorting algorithms ranges from $\mathcal{O}(n^2)$ being the worst to $\mathcal{O}(n~log~n)$ being the best. The purpose of a parallel sorting algorithm is to be more efficient than the serial implementation.

Sorting algorithm can be divided into two groups, namely comparison and non-comparison sorts. The comparison sort algorithms compares all elements e.g. using a compare and swap operation. Two elements are compared using e.g. less than or equal to, which determines which elements to come first in a sorted array. The non-comparison sorts, use other means for sorting an array. Different parallel sorting algorithm both comparison and non-comparison will be presented in the following sections. 